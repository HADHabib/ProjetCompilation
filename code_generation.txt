Object:
  Alloc one instance by inlining constructor at the start and remember the offset
  Create all method and use them with the global offset as this

Class:
  Alloc a VTable and fill it with the functions accordingly -> remember that the object has one more field
  Create all method and the constructor (choose emplacement of 'this')
  for the constructor, 'this' is the first arg. Implicitly set the vtable.

Method:
  - "def [override] fun(params) : ret := expr" =
     _CODE(expr)
     _STORE(return_register)
     RETURN
  - "def [override] fun(params) [: ret] is bloc" =
     _CODE(bloc)

Bloc:
  - "{ instrs }" = _CODE(instrs)
  - "{ decls is instrs }" =
     PUSHN len(decls)
     _CODE(instrs)

Instruction:
  - "expr;" =
     _CODE(expr)
     POPN 1 -- on ne laisse pas le resultat de l'expression sur la pile ?
  - "bloc" = CODE(bloc)
  - "return;" =
     -- Nettoyer la pile ?
     RETURN
  - "val := expr;" =
     _CODE(expr)
     _STORE(val)
  - "if expr then instr1 else instr2" =
     _CODE(expr)
     JZ label_else
     _CODE(instr1)
     JUMP label_endif
   label_else:
     _CODE(instr2)
   label_endif:
     NOP

Expression:
  - "val" = GET(val)
  - "expr1 op expr2" =
     _CODE(expr1)
     _CODE(expr2)
     _INSTR(op)
  - "not expr" =
     _CODE(expr)
     NOT
  - "- expr" =
     _CODE(expr)
     PUSHI -1
     MUL
  - "new class(params)" =
     ALLOC sizeof(class)
     _CODE(Call(class__constructor, params))

Call:
  - "fun(exprs)" =
     _CODE(exprs)
     PUSHA fun
     CALL
     POPN len(exprs)

MethodCall:
  - "a.fun(exprs)" =
     _GET(a)
     _CODE(exprs)
     _GET(a)
     LOAD 0 -- VTable
     LOAD index(fun)
     CALL
     POPN len(exprs)+1

-> define _GET & _STORE
