Object:
  Alloc one instance by inlining constructor at the start and remember the offset
  Create all method and use them with the global offset as this

Class:
  Alloc a VTable and fill it with the functions accordingly -> remember that the object has one more field
  Create all method and the constructor (choose emplacement of 'this')
  for the constructor, 'this' is the first arg. Implicitly set the vtable.

Method:
  - "def [override] fun(params) : ret := expr" =
   class_fun:
     _CODE(expr)
     _STORE(return_register)
     RETURN
  - "def [override] fun(params) [: ret] is bloc" =
   class_fun:
     _CODE(bloc)
     RETURN

Bloc:
  - "{ instrs }" = _CODE(instrs)
  - "{ decls is instrs }" =
     PUSHN len(decls)
     _CODE(instrs)

Instruction:
  - "expr;" =
     _CODE(expr)
     POPN 1 -- on ne laisse pas le resultat de l'expression sur la pile ?
  - "bloc" = _CODE(bloc)
  - "return;" =
     -- Nettoyer la pile ?
     RETURN
  - "val := expr;" =
     _CODE(expr)
     _STORE(val)
  - "if expr then instr1 else instr2" =
     _CODE(expr)
     JZ label_else
     _CODE(instr1)
     JUMP label_endif
   label_else:
     _CODE(instr2)
   label_endif:
     NOP

Expression:
  - "val" = _GET(val)
  - "expr1 op expr2" =
     _CODE(expr1)
     _CODE(expr2)
     _INSTR(op)
  - "not expr" =
     _CODE(expr)
     NOT
  - "- expr" =
     _CODE(expr)
     PUSHI -1
     MUL
  - "new class(params)" =
     ALLOC sizeof(class)
     _CODE(Call(class__constructor, params))

Call:
  - "fun(exprs)" =
     _CODE(exprs)
     PUSHA fun
     CALL
     POPN len(exprs)

Get  Value:
  - "100" = PUSHI 100
  - ""a"" = PUSHS "a"
  - "var" =>   "G/L/O" X ->  PUSHG X/ PUSHL X/ LOAD X
  - "val1.field" =
     _GET(val1)
     _GET(field)
  - "a.fun(exprs)" =
     _GET(a)
     _CODE(exprs)
     _GET(a)
     LOAD 0 -- VTable
     LOAD index(fun)
     CALL
     POPN len(exprs)+1

Store in Value:
  - Cst/Str/Method -> Error
  - "var" =>   "G/L/O" X ->  STOREG X/ STOREL X/ STORE X
  - "val1.field" =
     _GET(val1)
     _STORE(field)


Attribut : 
 atribus de verification et de generation de code : 
   
   Verification :
    - Type : 
    - ScopeVariable :  l'ensemble de variable qui sont visible dans un endroit precis.  (Visible ou non) ( Nom + Type )
    - ScopeMethod : l'ensemble de methode qui sont visible dans un endroit precis. (Visible ou non) ( Nom + TypeDeRetour + TypeParametre )
    - ScopeClass : l'ensemble de classe qui sont visible dans un endroit precis. (Visible ou non) ( champs + methodes + constructeur )

   Generation de code :
      -G/L/O :  G = Global , L = Local , O = Object 
      -X : offset de la variable.
      -index : index de la methode dans la vtable.
   
Type a cree  :

   TypeVariable : doit contenir un nom pour le scope le Type ainsi que le GLO X  pour la generation de code.
   TypeMethod : doit contenir un nom Type de retour et type de parametre pour le score ainsi que l'index dans la Vtable pour la generation de code.
   TypeClass : Doit contenir le nom de la class, ses Champs , ses method et son constructeur et potentiellement les parents.




Clement : Analyse Syntaxique 

DECRIR LES methodes a cree  : 
   - parcourir toutes le programme et verifie et affecte les GLOX 
   - Niveau global il faut verifier que les classes sont bien definie et que les methodes sont bien definie. ( une list de class et une list de methode)
   - verifClass : verifie que les champs ont un type correct et que les methodes sont bien definie. elle renvoie une class et elle est stocker dans la list de class du niveau du dessus.
   - verifieObjet : comme class mais renvoie une list de methode static 
   - verifieMethod : verifie que les parametre et le type de retour sont correct. elle renvoie une methode et elle est stocker dans la list de methode du niveau du dessus.
   - verifieType : verifie que le type est correct et renvoie le type.
   
   - verifieBloc : verifie que le bloc est correct et affect les GLOX.

   - Chaque fonction passe le score de methode qui est cree en haut et le scope de variable qui est cree pour les blocs.   (scope de variable est une list de list de variable)
